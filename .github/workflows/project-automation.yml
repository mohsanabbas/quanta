name: Project Automation

on:
  issues:
    types: [opened, labeled]
  pull_request:
    types: [opened, labeled, ready_for_review]
  workflow_dispatch:

permissions:
  issues: read
  pull-requests: read
  contents: read

jobs:
  add_to_project:
    runs-on: ubuntu-latest
    env:
      OWNER_LOGIN: "mohsanabbas"
      PROJECT_NUMBER: "2"
    steps:
      - name: Add item to project & set fields
        uses: actions/github-script@v7
        with:
          # PAT with scopes: repo, project
          github-token: ${{ secrets.QUANTA_PROJECT_TOKEN }}
          script: |
            const isIssue = !!context.payload.issue;
            const isPR    = !!context.payload.pull_request;
            if (!isIssue && !isPR) {
              core.info("Not an issue or PR event; skipping.");
              return;
            }

            const owner         = process.env.OWNER_LOGIN;
            const projectNumber = parseInt(process.env.PROJECT_NUMBER, 10);
            if (!owner || !projectNumber) {
              core.setFailed("OWNER_LOGIN or PROJECT_NUMBER not set");
              return;
            }

            const nodeId = isIssue
              ? context.payload.issue.node_id
              : context.payload.pull_request.node_id;

            // --- Union-safe field lookup (both org and user; your case is user)
            const projQueryOrg = `
              query($login: String!, $number: Int!) {
                organization(login: $login) {
                  projectV2(number: $number) {
                    id
                    fields(first: 50) {
                      nodes {
                        __typename
                        ... on ProjectV2FieldCommon { id name dataType }
                        ... on ProjectV2SingleSelectField { id name dataType options { id name } }
                      }
                    }
                  }
                }
              }
            `;
            const projQueryUser = `
              query($login: String!, $number: Int!) {
                user(login: $login) {
                  projectV2(number: $number) {
                    id
                    fields(first: 50) {
                      nodes {
                        __typename
                        ... on ProjectV2FieldCommon { id name dataType }
                        ... on ProjectV2SingleSelectField { id name dataType options { id name } }
                      }
                    }
                  }
                }
              }
            `;

            let projectId = null;
            let fields    = [];
            try {
              const r = await github.graphql(projQueryOrg, { login: owner, number: projectNumber });
              if (r?.organization?.projectV2) {
                projectId = r.organization.projectV2.id;
                fields    = r.organization.projectV2.fields.nodes;
              }
            } catch (e) {
              core.info("Org project lookup failed (ok for user projects): " + (e?.message || e));
            }
            if (!projectId) {
              const r2 = await github.graphql(projQueryUser, { login: owner, number: projectNumber });
              if (r2?.user?.projectV2) {
                projectId = r2.user.projectV2.id;
                fields    = r2.user.projectV2.fields.nodes;
              }
            }
            if (!projectId) {
              core.setFailed("Could not resolve ProjectV2. Check OWNER_LOGIN/PROJECT_NUMBER and token scope.");
              return;
            }

            const byName        = (n) => fields.find(f => f.name === n);
            const statusField   = byName("Status");
            const priorityField = byName("Priority");
            const epicField     = byName("Epic");

            // --- Add content to project or recover existing item
            let itemId = null;
            const addMutation = `
              mutation($project: ID!, $content: ID!) {
                addProjectV2ItemById(input: { projectId: $project, contentId: $content }) {
                  item { id }
                }
              }
            `;
            try {
              const addRes = await github.graphql(addMutation, { project: projectId, content: nodeId });
              itemId = addRes.addProjectV2ItemById.item.id;
            } catch (e) {
              // If already added, locate it
              const itemsQuery = `
                query($project: ID!, $after: String) {
                  node(id: $project) {
                    ... on ProjectV2 {
                      items(first: 100, after: $after) {
                        nodes {
                          id
                          content { __typename ... on Issue { id } ... on PullRequest { id } }
                        }
                        pageInfo { hasNextPage endCursor }
                      }
                    }
                  }
                }
              `;
              let cursor = null;
              while (true) {
                const res = await github.graphql(itemsQuery, { project: projectId, after: cursor });
                const items = res.node.items.nodes;
                const found = items.find(it => it.content?.id === nodeId);
                if (found) { itemId = found.id; break; }
                if (!res.node.items.pageInfo.hasNextPage) break;
                cursor = res.node.items.pageInfo.endCursor;
              }
              if (!itemId) {
                core.setFailed("Failed to add or locate project item: " + (e?.message || e));
                return;
              }
            }

            // --- Helpers (handles ID! vs String! schema differences)
            async function updateSingleSelectValue(fieldId, optionId) {
              const mutID = `
                mutation($project: ID!, $item: ID!, $field: ID!, $opt: ID!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $project, itemId: $item, fieldId: $field,
                    value: { singleSelectOptionId: $opt }
                  }) { projectV2Item { id } clientMutationId }
                }
              `;
              const mutStr = `
                mutation($project: ID!, $item: ID!, $field: ID!, $opt: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $project, itemId: $item, fieldId: $field,
                    value: { singleSelectOptionId: $opt }
                  }) { projectV2Item { id } clientMutationId }
                }
              `;
              try {
                return await github.graphql(mutID, {
                  project: projectId, item: itemId, field: fieldId, opt: optionId
                });
              } catch (e) {
                const msg = (e && e.message) ? e.message : String(e);
                if (msg.includes("Type mismatch") || msg.includes("ID! / String") || msg.includes("String! / ID")) {
                  core.info("Retrying singleSelectOptionId with String variable type.");
                  return await github.graphql(mutStr, {
                    project: projectId, item: itemId, field: fieldId, opt: optionId
                  });
                }
                throw e;
              }
            }

            async function setSingleSelect(field, optionName) {
              if (!field || !optionName) return;
              const opt = field.options?.find(o => o.name === optionName);
              if (!opt) {
                core.info(`Option "${optionName}" not found for field "${field.name}". Skipping.`);
                return;
              }
              await updateSingleSelectValue(field.id, opt.id);
            }

            async function setText(field, text) {
              if (!field || !text) return;
              const mut = `
                mutation($project: ID!, $item: ID!, $field: ID!, $text: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $project, itemId: $item, fieldId: $field,
                    value: { text: $text }
                  }) { projectV2Item { id } clientMutationId }
                }
              `;
              await github.graphql(mut, { project: projectId, item: itemId, field: field.id, text });
            }

            // --- Defaults/Derivations
            if (statusField) {
              await setSingleSelect(statusField, "Todo");
              if (statusField.options && !statusField.options.find(o => o.name === "Todo")) {
                await setSingleSelect(statusField, "To do");
              }
            }

            const labelsList = (isIssue ? context.payload.issue.labels : context.payload.pull_request.labels) || [];
            const prio = labelsList.map(l => l.name).find(n => ["P0","P1","P2","P3"].includes(n));
            if (prio && priorityField) {
              await setSingleSelect(priorityField, prio);
            }

            if (isIssue && epicField && context.payload.issue.body) {
              const m = context.payload.issue.body.match(/Epic:\s*(#[0-9]+)/i);
              if (m) await setText(epicField, m[1]);
            }
