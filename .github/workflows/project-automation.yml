name: Project Automation

on:
  issues:
    types: [opened, edited, labeled]
  pull_request:
    types: [opened, edited, labeled, ready_for_review]
  workflow_dispatch:

permissions:
  issues: read
  pull-requests: read
  contents: read

jobs:
  add_to_project:
    runs-on: ubuntu-latest
    env:
      OWNER_LOGIN: "mohsanabbas"
      PROJECT_NUMBER: "2"
    steps:
      - name: Add item to project & set fields
        uses: actions/github-script@v7
        with:
          # Personal access token secret with `project` + `repo` scopes
          github-token: ${{ secrets.QUANTA_PROJECT_TOKEN }}
          script: |
            const isIssue = !!context.payload.issue;
            const isPR    = !!context.payload.pull_request;
            if (!isIssue && !isPR) return;

            const owner        = process.env.OWNER_LOGIN;
            const projectNumber = parseInt(process.env.PROJECT_NUMBER, 10);
            if (!owner || !projectNumber) {
              core.setFailed("OWNER_LOGIN or PROJECT_NUMBER not set");
              return;
            }

            const nodeId = isIssue
              ? context.payload.issue.node_id
              : context.payload.pull_request.node_id;

            // GraphQL queries: project fields. Use inline fragments for union types.
            const projQueryOrg = `
              query($login: String!, $number: Int!) {
                organization(login: $login) {
                  projectV2(number: $number) {
                    id
                    fields(first: 50) {
                      nodes {
                        __typename
                        ... on ProjectV2FieldCommon {
                          id
                          name
                          dataType
                        }
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          dataType
                          options { id name }
                        }
                      }
                    }
                  }
                }
              }
            `;
            const projQueryUser = `
              query($login: String!, $number: Int!) {
                user(login: $login) {
                  projectV2(number: $number) {
                    id
                    fields(first: 50) {
                      nodes {
                        __typename
                        ... on ProjectV2FieldCommon {
                          id
                          name
                          dataType
                        }
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          dataType
                          options { id name }
                        }
                      }
                    }
                  }
                }
              }
            `;

            let projectId = null;
            let fields = [];
            try {
              const r = await github.graphql(projQueryOrg, { login: owner, number: projectNumber });
              if (r?.organization?.projectV2) {
                projectId = r.organization.projectV2.id;
                fields = r.organization.projectV2.fields.nodes;
              }
            } catch (e) {
              // ignore error from org query; fallback to user
            }
            if (!projectId) {
              const r2 = await github.graphql(projQueryUser, { login: owner, number: projectNumber });
              if (r2?.user?.projectV2) {
                projectId = r2.user.projectV2.id;
                fields    = r2.user.projectV2.fields.nodes;
              }
            }
            if (!projectId) {
              core.setFailed("Could not resolve ProjectV2. Check OWNER_LOGIN/PROJECT_NUMBER and token scope.");
              return;
            }

            // Helper to find field by name
            const byName = (n) => fields.find(f => f.name === n);
            const statusField  = byName("Status");
            const priorityField = byName("Priority");
            const epicField    = byName("Epic");

            // Add item to project or find existing item ID
            let itemId = null;
            const addMutation = `
              mutation($project: ID!, $content: ID!) {
                addProjectV2ItemById(input: {projectId: $project, contentId: $content}) {
                  item { id }
                }
              }
            `;
            try {
              const addRes = await github.graphql(addMutation, { project: projectId, content: nodeId });
              itemId = addRes.addProjectV2ItemById.item.id;
            } catch (e) {
              // If item already exists, find it by content id
              const itemsQuery = `
                query($project: ID!, $after: String) {
                  node(id: $project) {
                    ... on ProjectV2 {
                      items(first: 100, after: $after) {
                        nodes {
                          id
                          content { __typename ... on Issue { id } ... on PullRequest { id } }
                        }
                        pageInfo { hasNextPage endCursor }
                      }
                    }
                  }
                }
              `;
              let cursor = null;
              while (true) {
                const res = await github.graphql(itemsQuery, { project: projectId, after: cursor });
                const items = res.node.items.nodes;
                const found = items.find(it => it.content?.id === nodeId);
                if (found) { itemId = found.id; break; }
                if (!res.node.items.pageInfo.hasNextPage) break;
                cursor = res.node.items.pageInfo.endCursor;
              }
              if (!itemId) {
                core.setFailed("Failed to add or locate project item: " + e.message);
                return;
              }
            }

            // Helper to set single-select field value
            async function setSingleSelect(field, optionName) {
              if (!field || !optionName) return;
              const opt = field.options?.find(o => o.name === optionName);
              if (!opt) return;
              const mut = `
                mutation($project: ID!, $item: ID!, $field: ID!, $opt: ID!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $project,
                    itemId:   $item,
                    fieldId:  $field,
                    value:    { singleSelectOptionId: $opt }
                  }) { item { id } }
                }
              `;
              await github.graphql(mut, { project: projectId, item: itemId, field: field.id, opt: opt.id });
            }
            // Helper to set text field value
            async function setText(field, text) {
              if (!field || !text) return;
              const mut = `
                mutation($project: ID!, $item: ID!, $field: ID!, $text: String!) {
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $project,
                    itemId:   $item,
                    fieldId:  $field,
                    value:    { text: $text }
                  }) { item { id } }
                }
              `;
              await github.graphql(mut, { project: projectId, item: itemId, field: field.id, text });
            }

            // Default Status = Todo (fallback to "To do" if option missing)
            if (statusField) {
              await setSingleSelect(statusField, "Todo");
              if (statusField.options && !statusField.options.find(o => o.name === "Todo")) {
                await setSingleSelect(statusField, "To do");
              }
            }

            // Set Priority based on label (P0..P3)
            const labelsList = (isIssue ? context.payload.issue.labels : context.payload.pull_request.labels) || [];
            const prio = labelsList.map(l => l.name).find(n => ["P0","P1","P2","P3"].includes(n));
            if (prio) {
              await setSingleSelect(priorityField, prio);
            }

            // Set Epic field from issue body (look for "Epic: #ID")
            if (isIssue && context.payload.issue.body) {
              const m = context.payload.issue.body.match(/Epic:\s*(#[0-9]+)/i);
              if (m) {
                await setText(epicField, m[1]);
              }
            }
